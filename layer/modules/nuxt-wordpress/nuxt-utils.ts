import { addTemplate, useNuxt, createResolver } from '@nuxt/kit'

export function exposeModuleConfig(moduleName: string, config: Record<string, any>) {
  const { resolve } = createResolver(import.meta.url)
  const nuxt = useNuxt()
  const jsExports = Object.entries(config)
    .map(([k, v]) => `export const ${k} = ${JSON.stringify(v)}`)
    .join('\n')
  const alias = `#${moduleName}/config`
  nuxt.options.alias[alias] = addTemplate({
    filename: `modules/config/${moduleName}.mjs`,
    getContents: () => jsExports,
  }).dst

  // expose for nitro
  nuxt.hooks.hook('nitro:config', nitroConfig => {
    nitroConfig.virtual![alias] = jsExports
  })

  // need to create a ts def for the file
  const typeDefName = `modules/config/${moduleName}.d.ts`
  const tsExports = Object.keys(config)
    .map(k => {
      // expose actual values in dev
      if (nuxt.options.dev) return `  export const ${k}: ${JSON.stringify(config[k])} | ModuleOptions['${k}']`
      return `  export const ${k}: ModuleOptions['${k}']`
    })
    .join('\n')
  addTemplate({
    filename: typeDefName,
    getContents: () => {
      return `// generated by ${moduleName}
import type { ModuleOptions } from '${moduleName}'
declare module '${alias}' {
${tsExports}
}
`
    },
  })
  nuxt.hooks.hook('prepare:types', ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, typeDefName) })
  })
  // return the alias as #nuxt-my-module/config
  return alias
}
